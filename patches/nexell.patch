diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/arch/arm/Kconfig kernel-2.6.33/arch/arm/Kconfig
--- linux-2.6.33.7.2-rt30/arch/arm/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/arch/arm/Kconfig	2011-05-11 17:36:32.000000000 +0300
@@ -641,9 +641,16 @@
 	help
 	  Samsung S5PC1XX series based systems
 
+config ARCH_NEXELL
+	bool "Nexell's ARM SOC"
+	select GENERIC_CLOCKEVENTS
+	help
+	  Nexell arm based systems
+	  
+
 config ARCH_SHARK
 	bool "Shark"
-	select CPU_SA110
+	select CPU_SA110                           
 	select ISA
 	select ISA_DMA
 	select ZONE_DMA
@@ -808,6 +815,11 @@
 source "arch/arm/plat-s3c/Kconfig"
 source "arch/arm/plat-s5pc1xx/Kconfig"
 
+if ARCH_NEXELL
+source "arch/arm/plat-nexell/Kconfig"
+source "arch/arm/mach-nxp2120/Kconfig"
+endif
+
 if ARCH_S3C2410
 source "arch/arm/mach-s3c2400/Kconfig"
 source "arch/arm/mach-s3c2410/Kconfig"
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/arch/arm/Kconfig.debug kernel-2.6.33/arch/arm/Kconfig.debug
--- linux-2.6.33.7.2-rt30/arch/arm/Kconfig.debug	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/arch/arm/Kconfig.debug	2011-05-11 17:36:32.000000000 +0300
@@ -127,5 +127,15 @@
 
 	  The uncompressor code port configuration is now handled
 	  by CONFIG_S3C_LOWLEVEL_UART_PORT.
+	  
+config DEBUG_NEXELL_UART
+    depends on PLAT_NEXELL
+    int "NEXELL UART to use for low-level debug"
+    default "0"
+    help
+        Choice for UART for kernel low-level using NEXELL UARTS,
+	    should be between zero and one. The port must have been
+	    initialised by the boot-loader before use.
+      
 
 endmenu
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/arch/arm/kernel/process.c kernel-2.6.33/arch/arm/kernel/process.c
--- linux-2.6.33.7.2-rt30/arch/arm/kernel/process.c	2016-06-18 12:51:17.649353319 +0300
+++ kernel-2.6.33/arch/arm/kernel/process.c	2012-03-05 14:01:34.000000000 +0200
@@ -194,6 +194,7 @@
 
 void machine_halt(void)
 {
+	arch_halt();
 }
 
 
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/arch/arm/Makefile kernel-2.6.33/arch/arm/Makefile
--- linux-2.6.33.7.2-rt30/arch/arm/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/arch/arm/Makefile	2011-05-11 17:36:32.000000000 +0300
@@ -150,6 +150,7 @@
 machine-$(CONFIG_ARCH_NETX)		:= netx
 machine-$(CONFIG_ARCH_NOMADIK)		:= nomadik
 machine-$(CONFIG_ARCH_NS9XXX)		:= ns9xxx
+machine-$(CONFIG_ARCH_NEXELL)       := nxp2120
 machine-$(CONFIG_ARCH_OMAP1)		:= omap1
 machine-$(CONFIG_ARCH_OMAP2)		:= omap2
 machine-$(CONFIG_ARCH_OMAP3)		:= omap2
@@ -180,6 +181,7 @@
 plat-$(CONFIG_ARCH_STMP3XXX)	:= stmp3xxx
 plat-$(CONFIG_PLAT_IOP)		:= iop
 plat-$(CONFIG_PLAT_NOMADIK)	:= nomadik
+plat-$(CONFIG_PLAT_NEXELL)      := nexell
 plat-$(CONFIG_PLAT_ORION)	:= orion
 plat-$(CONFIG_PLAT_PXA)		:= pxa
 plat-$(CONFIG_PLAT_S3C24XX)	:= s3c24xx s3c samsung
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/arch/arm/tools/mach-types kernel-2.6.33/arch/arm/tools/mach-types
--- linux-2.6.33.7.2-rt30/arch/arm/tools/mach-types	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/arch/arm/tools/mach-types	2011-05-11 17:36:32.000000000 +0300
@@ -2678,3 +2678,4 @@
 mioa702			MACH_MIOA702		MIOA702			2691
 hpmin			MACH_HPMIN		HPMIN			2692
 ak880xak		MACH_AK880XAK		AK880XAK		2693
+nxp2120                 MACH_NXP2120            NXP2120                 2120
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/char/Kconfig kernel-2.6.33/drivers/char/Kconfig
--- linux-2.6.33.7.2-rt30/drivers/char/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/char/Kconfig	2011-05-11 17:36:32.000000000 +0300
@@ -901,6 +901,12 @@
 
 	  If unsure, say N.
 
+config MOSTGPLED
+	tristate "Mostitech/LGE GPLED driver"
+	depends on ARCH_NEXELL
+	---help---
+	This driver provide compatible interface for GPLED. 
+
 config R3964
 	tristate "Siemens R3964 line discipline"
 	---help---
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/char/Makefile kernel-2.6.33/drivers/char/Makefile
--- linux-2.6.33.7.2-rt30/drivers/char/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/char/Makefile	2011-05-11 17:36:32.000000000 +0300
@@ -97,6 +97,7 @@
 obj-$(CONFIG_CS5535_GPIO)	+= cs5535_gpio.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
+obj-$(CONFIG_MOSTGPLED)         += mostgpled.o
 
 obj-$(CONFIG_MWAVE)		+= mwave/
 obj-$(CONFIG_AGP)		+= agp/
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/i2c/busses/Kconfig kernel-2.6.33/drivers/i2c/busses/Kconfig
--- linux-2.6.33.7.2-rt30/drivers/i2c/busses/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/i2c/busses/Kconfig	2011-05-11 17:36:32.000000000 +0300
@@ -565,6 +565,22 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-versatile.
 
+config I2C_NEXELL
+	tristate "Nexell I2C (NX series)"
+	depends on ARCH_NEXELL
+	help
+	  Support for NX series processor's I2C driver.
+
+config I2C_NEXELL_PORT0
+	bool "Nexell I2C port 0"
+	depends on I2C_NEXELL
+	default y
+
+config I2C_NEXELL_PORT1
+	bool "Nexell I2C port 1"
+	depends on I2C_NEXELL
+	default n
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_PARPORT
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/i2c/busses/Makefile kernel-2.6.33/drivers/i2c/busses/Makefile
--- linux-2.6.33.7.2-rt30/drivers/i2c/busses/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/i2c/busses/Makefile	2011-05-11 17:36:32.000000000 +0300
@@ -54,6 +54,7 @@
 obj-$(CONFIG_I2C_SIMTEC)	+= i2c-simtec.o
 obj-$(CONFIG_I2C_STU300)	+= i2c-stu300.o
 obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
+obj-$(CONFIG_I2C_NEXELL)	+= i2c-nexell.o
 
 # External I2C/SMBus adapter drivers
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/media/video/Kconfig kernel-2.6.33/drivers/media/video/Kconfig
--- linux-2.6.33.7.2-rt30/drivers/media/video/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/media/video/Kconfig	2011-05-11 17:36:32.000000000 +0300
@@ -806,6 +806,16 @@
 	  This is a video4linux2 driver for the Marvell 88ALP01 integrated
 	  CMOS camera controller.  This is the controller found on first-
 	  generation OLPC systems.
+	  
+config VIDEO_NEXELL
+	tristate "Nexell Camera Capture Interface driver"
+	depends on VIDEO_DEV && ARCH_NEXELL
+	---help---
+	  This is a v4l2 driver for the Nexell VIP camera capture interface
+
+if VIDEO_NEXELL
+source "drivers/media/video/nexell/Kconfig"
+endif
 
 config SOC_CAMERA
 	tristate "SoC camera support"
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/media/video/Makefile kernel-2.6.33/drivers/media/video/Makefile
--- linux-2.6.33.7.2-rt30/drivers/media/video/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/media/video/Makefile	2011-05-11 17:36:32.000000000 +0300
@@ -107,6 +107,7 @@
 obj-$(CONFIG_VIDEO_MXB) += mxb.o
 obj-$(CONFIG_VIDEO_HEXIUM_ORION) += hexium_orion.o
 obj-$(CONFIG_VIDEO_HEXIUM_GEMINI) += hexium_gemini.o
+obj-$(CONFIG_VIDEO_NEXELL)	+= nexell/
 
 obj-$(CONFIG_VIDEOBUF_GEN) += videobuf-core.o
 obj-$(CONFIG_VIDEOBUF_DMA_SG) += videobuf-dma-sg.o
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/mtd/mtdblock.c kernel-2.6.33/drivers/mtd/mtdblock.c
--- linux-2.6.33.7.2-rt30/drivers/mtd/mtdblock.c	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/mtd/mtdblock.c	2013-07-17 17:08:32.000000000 +0300
@@ -18,6 +18,10 @@
 #include <linux/mtd/blktrans.h>
 #include <linux/mutex.h>
 
+// ksw : READERROR Correction for SQUASHFS 
+#ifdef CONFIG_SQUASHFS
+#define CONFIG_SQUASHFS_NAND_EUCLEAN_SKIP
+#endif
 
 static struct mtdblk_dev {
 	struct mtd_info *mtd;
@@ -245,7 +249,17 @@
 			      unsigned long block, char *buf)
 {
 	struct mtdblk_dev *mtdblk = mtdblks[dev->devnum];
+#if defined(CONFIG_SQUASHFS_NAND_EUCLEAN_SKIP)
+	int ret;
+
+	ret = do_cached_read(mtdblk, block<<9, 512, buf);
+	if ((dev->devnum == 2) && (ret == -EUCLEAN))
+		return 0;
+	else
+		return ret;
+#else
 	return do_cached_read(mtdblk, block<<9, 512, buf);
+#endif	
 }
 
 static int mtdblock_writesect(struct mtd_blktrans_dev *dev,
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/mtd/mtdpart.c kernel-2.6.33/drivers/mtd/mtdpart.c
--- linux-2.6.33.7.2-rt30/drivers/mtd/mtdpart.c	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/mtd/mtdpart.c	2011-05-11 17:36:32.000000000 +0300
@@ -19,6 +19,26 @@
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/compatmac.h>
 
+#define CONFIG_MTD_REMAP_SQUASHFS	1
+#define DEBUG_REMAP	0
+
+#if CONFIG_MTD_REMAP_SQUASHFS
+/* Walson: definicate two mapping table for squashfs
++ * partition, because squashfs do not know bad block.
++ * So the we have do the valid mapping between logic block
++ * and phys block
++ */
+#include <linux/mtd/nand.h>
+#define MAX_PARTITION_MAPPING   2
+struct part_map{
+    struct mtd_info *part_mtd;  /* Mapping partition mtd */
+    unsigned *map_table;        /* Mapping from logic block to phys block */
+    unsigned nBlock;            /* Logic block number */
+};
+
+static struct part_map *part_mapping[MAX_PARTITION_MAPPING];
+static int part_mapping_count = -1;
+#endif
 /* Our partition linked list */
 static LIST_HEAD(mtd_partitions);
 
@@ -49,6 +69,35 @@
 	struct mtd_ecc_stats stats;
 	int res;
 
+#if CONFIG_MTD_REMAP_SQUASHFS
+	/* Walson: calucate physical address */  
+	struct nand_chip *this = part->master->priv;
+	unsigned logic_b, phys_b;
+	unsigned i;
+
+	if ( part_mapping_count > 0 )
+	{
+		for ( i=0; i<MAX_PARTITION_MAPPING; i++ )
+		{
+			if ( part_mapping[i] && part_mapping[i]->part_mtd==mtd )
+			{
+				/* remap from logic block to physical block */  
+				logic_b = from >> this->bbt_erase_shift;
+				if ( logic_b < part_mapping[i]->nBlock )
+				{
+					phys_b = part_mapping[i]->map_table[logic_b];
+					from = phys_b << this->bbt_erase_shift | (from&(mtd->erasesize-1));
+				}
+				else
+				{
+					/* the offset is bigger than good block range, don't read data */
+					*retlen = 0;
+					return -EINVAL;
+				}
+			}
+		}
+	}
+#endif
 	stats = part->master->ecc_stats;
 
 	if (from >= mtd->size)
@@ -102,11 +151,41 @@
 {
 	struct mtd_part *part = PART(mtd);
 	int res;
-
+#if CONFIG_MTD_REMAP_SQUASHFS
+	/* ksw/Walson: calucate physical address */
+	struct nand_chip *this = part->master->priv;
+	unsigned logic_b, phys_b;
+	unsigned i;
+#endif
 	if (from >= mtd->size)
 		return -EINVAL;
 	if (ops->datbuf && from + ops->len > mtd->size)
 		return -EINVAL;
+#if CONFIG_MTD_REMAP_SQUASHFS
+	/* Walson: calucate physical address */
+	if ( part_mapping_count > 0 )
+	{
+		for ( i=0; i<MAX_PARTITION_MAPPING; i++ )
+		{
+			if ( part_mapping[i] && part_mapping[i]->part_mtd==mtd )
+			{
+				/* remap from logic block to physical block */  
+				logic_b = from >> this->bbt_erase_shift;
+				if ( logic_b < part_mapping[i]->nBlock )
+				{
+					phys_b = part_mapping[i]->map_table[logic_b];
+					from = phys_b << this->bbt_erase_shift | (from&(mtd->erasesize-1));
+				}
+				else
+				{
+					/* the offset is bigger than good block range, don't read data */
+					res = 0;
+					return -EINVAL;
+				}
+			}
+		}
+	}
+#endif
 	res = part->master->read_oob(part->master, from + part->offset, ops);
 
 	if (unlikely(res)) {
@@ -307,6 +386,107 @@
 	return res;
 }
 
+#if CONFIG_MTD_REMAP_SQUASHFS   
+/* Walson:
+ * This function create a partition mapping
+ */
+static int part_create_partition_mapping ( struct mtd_info *part_mtd )
+{
+	struct mtd_part *part = PART(part_mtd);
+	struct nand_chip *this = part->master->priv;
+	struct part_map *map_part;
+	int index;
+	uint64_t offset;
+	int logical_b, phys_b;
+
+	if ( !part_mtd || !this )
+	{
+		printk("null mtd or it is no nand chip!");
+		return -1;
+	}
+
+	if ( part_mapping_count < 0 )
+	{
+		/* Init the part mapping table when this function called first time */
+		memset(part_mapping, 0, sizeof(struct part_map *)*MAX_PARTITION_MAPPING);
+		part_mapping_count = 0;
+	}
+
+	for ( index=0; index<MAX_PARTITION_MAPPING; index++ )
+	{
+		if ( part_mapping[index] == NULL )
+			break;
+	}
+
+	if ( index >= MAX_PARTITION_MAPPING )
+	{
+		printk("partition mapping is full!");
+		return -1;
+	}
+
+	map_part = kmalloc(sizeof(struct part_map), GFP_KERNEL);
+	if ( !map_part )
+	{
+		printk ("memory allocation error while creating partitions mapping for %s\n",
+			part_mtd->name);
+		return -1;
+	}
+   
+	map_part->map_table = kmalloc(sizeof(unsigned)*(part_mtd->size>>this->bbt_erase_shift), GFP_KERNEL);
+	if ( !map_part->map_table )
+	{
+		printk ("memory allocation error while creating partitions mapping for %s\n",
+			part_mtd->name);
+		kfree(map_part);
+		return -1;
+	}
+	memset(map_part->map_table, 0xFF, sizeof(unsigned)*(part_mtd->size>>this->bbt_erase_shift));
+
+	/* Create partition mapping table */  
+	logical_b = 0;
+	for ( offset=0; offset<part_mtd->size; offset+=part_mtd->erasesize )
+	{
+		if ( part_mtd->block_isbad &&
+			part_mtd->block_isbad(part_mtd, offset) )
+			continue;
+
+		phys_b = offset >> this->bbt_erase_shift;
+		map_part->map_table[logical_b] = phys_b;
+#if DEBUG_REMAP
+		printk("part[%s]: logic[%u]=phys[%u]\n",
+			part_mtd->name, logical_b, phys_b);
+#endif
+		logical_b++;
+	}
+	map_part->nBlock = logical_b;
+	map_part->part_mtd = part_mtd;
+
+	part_mapping[index] = map_part;
+	part_mapping_count++;
+	return 0;
+}
+   
+static void part_del_partition_mapping( struct mtd_info *part_mtd )
+{
+	int index;
+	struct part_map *map_part;
+
+	if ( part_mapping_count > 0 )
+	{
+		for ( index=0; index<MAX_PARTITION_MAPPING; index++ )
+		{
+			map_part = part_mapping[index];
+			if ( map_part && map_part->part_mtd==part_mtd )
+			{
+				kfree(map_part->map_table);
+				kfree(map_part);
+				part_mapping[index] = NULL;
+				part_mapping_count--;
+			}
+		}
+	}
+}
+#endif
 /*
  * This function unregisters and destroy all slave MTD objects which are
  * attached to the given master MTD object.
@@ -318,6 +498,10 @@
 
 	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
 		if (slave->master == master) {
+#if CONFIG_MTD_REMAP_SQUASHFS
+			/* walson: Free partition mapping if created */  
+			part_del_partition_mapping(&slave->mtd);
+#endif
 			list_del(&slave->list);
 			del_mtd_device(&slave->mtd);
 			kfree(slave);
@@ -499,6 +683,14 @@
 out_register:
 	/* register our partition */
 	add_mtd_device(&slave->mtd);
+#if CONFIG_MTD_REMAP_SQUASHFS
+	/* Walson: Build partition mapping for squashfs */               
+	if ( slave->mtd.name && 0==strcmp(slave->mtd.name, "nand.rootfs"))	{                                   
+			part_create_partition_mapping(&slave->mtd);
+	}
+	else {
+	}
+#endif
 
 	return slave;
 }
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/mtd/nand/Kconfig kernel-2.6.33/drivers/mtd/nand/Kconfig
--- linux-2.6.33.7.2-rt30/drivers/mtd/nand/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/mtd/nand/Kconfig	2011-05-11 17:36:32.000000000 +0300
@@ -184,6 +184,25 @@
 	  incorrect ECC generation, and if using these, the default of
 	  software ECC is preferable.
 
+config MTD_NAND_NEXELL
+	tristate "Nexell Nand support (NX series)"
+	depends on ARCH_NEXELL
+	help
+	  This enables the NAND flash controller on the NX series
+
+config MTD_NAND_NEXELL_PARTS_MAP
+	bool "Support NAND partition map file (cfg_nand_map.h)"
+	depends on MTD_NAND_NEXELL && MTD_PARTITIONS
+	help
+	  Use NAND partition table header file (cfg_nand_map.h)
+
+config MTD_NAND_NEXELL_HWECC
+	bool "Nexell Nand Hardware ECC"
+	depends on MTD_NAND_NEXELL
+	help
+	  Enable the use of the NX series's internal ECC generator when
+	  using NAND.
+
 config MTD_NAND_NDFC
 	tristate "NDFC NanD Flash Controller"
 	depends on 4xx
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/mtd/nand/Makefile kernel-2.6.33/drivers/mtd/nand/Makefile
--- linux-2.6.33.7.2-rt30/drivers/mtd/nand/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/mtd/nand/Makefile	2011-05-11 17:36:32.000000000 +0300
@@ -42,5 +42,6 @@
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
 obj-$(CONFIG_MTD_NAND_BCM_UMI)		+= bcm_umi_nand.o nand_bcm_umi.o
+obj-$(CONFIG_MTD_NAND_NEXELL)		+= nexell/
 
 nand-objs := nand_base.o nand_bbt.o
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/net/dm9000.c kernel-2.6.33/drivers/net/dm9000.c
--- linux-2.6.33.7.2-rt30/drivers/net/dm9000.c	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/net/dm9000.c	2011-05-11 17:36:32.000000000 +0300
@@ -97,10 +97,11 @@
 	u8		io_mode;		/* 0:word, 2:byte */
 	u8		phy_addr;
 	u8		imr_all;
+	int    Speed;
+	int    op_mode;
 
 	unsigned int	flags;
 	unsigned int	in_suspend :1;
-	unsigned int	wake_supported :1;
 	int		debug_level;
 
 	enum dm9000_type type;
@@ -117,8 +118,6 @@
 	struct resource *data_req;
 	struct resource *irq_res;
 
-	int		 irq_wake;
-
 	struct mutex	 addr_lock;	/* phy and eeprom access lock */
 
 	struct delayed_work phy_poll;
@@ -128,7 +127,6 @@
 
 	struct mii_if_info mii;
 	u32		msg_enable;
-	u32		wake_state;
 
 	int		rx_csum;
 	int		can_csum;
@@ -151,6 +149,7 @@
 
 /* DM9000 network board routine ---------------------------- */
 
+#if !defined(CONFIG_MACH_SMDKV210) && !defined(CONFIG_MACH_VOGUEV210) && !defined(CONFIG_MACH_SMDKC110)
 static void
 dm9000_reset(board_info_t * db)
 {
@@ -162,6 +161,7 @@
 	writeb(NCR_RST, db->io_data);
 	udelay(200);
 }
+#endif
 
 /*
  *   Read a byte from I/O port
@@ -184,6 +184,31 @@
 	writeb(value, db->io_data);
 }
 
+#if defined(CONFIG_MACH_SMDKV210) || defined(CONFIG_MACH_VOGUEV210) || defined(CONFIG_MACH_SMDKC110)
+static void dm9000_reset(board_info_t *db)
+{
+	dev_dbg(db->dev, "resetting device\n");
+
+	iow(db, DM9000_GPCR, 0x0f);
+	iow(db, DM9000_GPR, 0);
+	iow(db, DM9000_NCR, 3);
+
+	do {
+		udelay(100);
+	} while (ior(db, DM9000_NCR) & 0x1);
+
+	iow(db, DM9000_NCR, 0);
+	iow(db, DM9000_NCR, 3);
+
+	do {
+		udelay(100);
+	} while (ior(db, DM9000_NCR) & 0x1);
+
+	if ((ior(db, DM9000_PIDL) != 0) || (ior(db, DM9000_PIDH) != 0x90))
+		printk(KERN_INFO "ERROR : resetting ");
+}
+#endif
+
 /* routines for sending block to chip */
 
 static void dm9000_outblk_8bit(void __iomem *reg, void *data, int count)
@@ -475,13 +500,17 @@
 	return dm->rx_csum;
 }
 
-static int dm9000_set_rx_csum_unlocked(struct net_device *dev, uint32_t data)
+static int dm9000_set_rx_csum(struct net_device *dev, uint32_t data)
 {
 	board_info_t *dm = to_dm9000_board(dev);
+	unsigned long flags;
 
 	if (dm->can_csum) {
 		dm->rx_csum = data;
+
+		spin_lock_irqsave(&dm->lock, flags);
 		iow(dm, DM9000_RCSR, dm->rx_csum ? RCSR_CSUM : 0);
+		spin_unlock_irqrestore(&dm->lock, flags);
 
 		return 0;
 	}
@@ -489,19 +518,6 @@
 	return -EOPNOTSUPP;
 }
 
-static int dm9000_set_rx_csum(struct net_device *dev, uint32_t data)
-{
-	board_info_t *dm = to_dm9000_board(dev);
-	unsigned long flags;
-	int ret;
-
-	spin_lock_irqsave(&dm->lock, flags);
-	ret = dm9000_set_rx_csum_unlocked(dev, data);
-	spin_unlock_irqrestore(&dm->lock, flags);
-
-	return ret;
-}
-
 static int dm9000_set_tx_csum(struct net_device *dev, uint32_t data)
 {
 	board_info_t *dm = to_dm9000_board(dev);
@@ -581,54 +597,6 @@
 	return 0;
 }
 
-static void dm9000_get_wol(struct net_device *dev, struct ethtool_wolinfo *w)
-{
-	board_info_t *dm = to_dm9000_board(dev);
-
-	memset(w, 0, sizeof(struct ethtool_wolinfo));
-
-	/* note, we could probably support wake-phy too */
-	w->supported = dm->wake_supported ? WAKE_MAGIC : 0;
-	w->wolopts = dm->wake_state;
-}
-
-static int dm9000_set_wol(struct net_device *dev, struct ethtool_wolinfo *w)
-{
-	board_info_t *dm = to_dm9000_board(dev);
-	unsigned long flags;
-	u32 opts = w->wolopts;
-	u32 wcr = 0;
-
-	if (!dm->wake_supported)
-		return -EOPNOTSUPP;
-
-	if (opts & ~WAKE_MAGIC)
-		return -EINVAL;
-
-	if (opts & WAKE_MAGIC)
-		wcr |= WCR_MAGICEN;
-
-	mutex_lock(&dm->addr_lock);
-
-	spin_lock_irqsave(&dm->lock, flags);
-	iow(dm, DM9000_WCR, wcr);
-	spin_unlock_irqrestore(&dm->lock, flags);
-
-	mutex_unlock(&dm->addr_lock);
-
-	if (dm->wake_state != opts) {
-		/* change in wol state, update IRQ state */
-
-		if (!dm->wake_state)
-			set_irq_wake(dm->irq_wake, 1);
-		else if (dm->wake_state & !opts)
-			set_irq_wake(dm->irq_wake, 0);
-	}
-
-	dm->wake_state = opts;
-	return 0;
-}
-
 static const struct ethtool_ops dm9000_ethtool_ops = {
 	.get_drvinfo		= dm9000_get_drvinfo,
 	.get_settings		= dm9000_get_settings,
@@ -637,8 +605,6 @@
 	.set_msglevel		= dm9000_set_msglevel,
 	.nway_reset		= dm9000_nway_reset,
 	.get_link		= dm9000_get_link,
-	.get_wol		= dm9000_get_wol,
-	.set_wol		= dm9000_set_wol,
  	.get_eeprom_len		= dm9000_get_eeprom_len,
  	.get_eeprom		= dm9000_get_eeprom,
  	.set_eeprom		= dm9000_set_eeprom,
@@ -730,7 +696,7 @@
  *  Set DM9000 multicast address
  */
 static void
-dm9000_hash_table_unlocked(struct net_device *dev)
+dm9000_hash_table(struct net_device *dev)
 {
 	board_info_t *db = netdev_priv(dev);
 	struct dev_mc_list *mcptr = dev->mc_list;
@@ -739,9 +705,12 @@
 	u32 hash_val;
 	u16 hash_table[4];
 	u8 rcr = RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN;
+	unsigned long flags;
 
 	dm9000_dbg(db, 1, "entering %s\n", __func__);
 
+	spin_lock_irqsave(&db->lock, flags);
+
 	for (i = 0, oft = DM9000_PAR; i < 6; i++, oft++)
 		iow(db, oft, dev->dev_addr[i]);
 
@@ -771,17 +740,144 @@
 	}
 
 	iow(db, DM9000_RCR, rcr);
+	spin_unlock_irqrestore(&db->lock, flags);
 }
 
-static void
-dm9000_hash_table(struct net_device *dev)
-{
-	board_info_t *db = netdev_priv(dev);
-	unsigned long flags;
+enum DM9KS_PHY_mode {
+	DM9KS_10MHD   = 0, 
+	DM9KS_100MHD  = 1, 
+	DM9KS_10MFD   = 4,
+	DM9KS_100MFD  = 5, 
+	DM9KS_AUTO    = 8, 
+};
 
-	spin_lock_irqsave(&db->lock, flags);
-	dm9000_hash_table_unlocked(dev);
-	spin_unlock_irqrestore(&db->lock, flags);
+static int dm9000_phy_read(struct net_device *dev, int phy_reg_unused, int reg);
+static void dm9000_phy_write(struct net_device *dev, int phyaddr_unused, int reg, int value);
+/* Set PHY operationg mode
+*/
+static void set_PHY_mode(struct net_device *dev)
+{
+    board_info_t *db = netdev_priv(dev);
+#ifndef DM8606
+	u16 phy_reg0 = 0x1000;/* Auto-negotiation*/
+	u16 phy_reg4 = 0x01e1;
+
+	if ( !(db->op_mode & DM9KS_AUTO) ) // op_mode didn't auto sense */
+	{ 
+		switch(db->op_mode) {
+			case DM9KS_10MHD:  phy_reg4 = 0x21; 
+                        	           phy_reg0 = 0x1000;
+					   break;
+			case DM9KS_10MFD:  phy_reg4 = 0x41; 
+					   phy_reg0 = 0x1100;
+                                	   break;
+			case DM9KS_100MHD: phy_reg4 = 0x81; 
+					   phy_reg0 = 0x3000;
+				    	   break;
+			case DM9KS_100MFD: phy_reg4 = 0x101; 
+					   phy_reg0 = 0x3100;
+				   	   break;
+			default: 
+					   break;
+		} // end of switch
+	} // end of if
+#ifdef FLOW_CONTROL
+	dm9000_phy_write(dev, 0,  4, phy_reg4|(1<<10));
+#else
+	dm9000_phy_write(dev, 0,  4, phy_reg4);
+#endif //end of FLOW_CONTROL
+	dm9000_phy_write(dev, 0,  0, phy_reg0|0x200);
+#else
+	/* Fiber mode */
+	dm9000_phy_write(dev, 0,  16, 0x4014);
+	dm9000_phy_write(dev, 0,  0, 0x2100);
+#endif //end of DM8606
+
+	if (db->type == TYPE_DM9000B) /* DM9000B */
+	{
+		//set 10M TX idle =65mA (TX 100% utility is 160mA)
+		dm9000_phy_write(dev, 0,  20, dm9000_phy_read(dev, 0, 20)|(1<<11)|(1<<10));
+		
+		//DM9000B:fix harmonic
+		//For short code:
+		//PHY_REG 27 (1Bh) <- 0000h
+		dm9000_phy_write(dev, 0,  27, 0x0000);
+		//PHY_REG 27 (1Bh) <- AA00h
+		dm9000_phy_write(dev, 0,  27, 0xaa00);
+
+		//PHY_REG 27 (1Bh) <- 0017h
+		dm9000_phy_write(dev, 0,  27, 0x0017);
+		//PHY_REG 27 (1Bh) <- AA17h
+		dm9000_phy_write(dev, 0,  27, 0xaa17);
+
+		//PHY_REG 27 (1Bh) <- 002Fh
+		dm9000_phy_write(dev, 0,  27, 0x002f);
+		//PHY_REG 27 (1Bh) <- AA2Fh
+		dm9000_phy_write(dev, 0,  27, 0xaa2f);
+		
+		//PHY_REG 27 (1Bh) <- 0037h
+		dm9000_phy_write(dev, 0,  27, 0x0037);
+		//PHY_REG 27 (1Bh) <- AA37h
+		dm9000_phy_write(dev, 0,  27, 0xaa37);
+		
+		//PHY_REG 27 (1Bh) <- 0040h
+		dm9000_phy_write(dev, 0,  27, 0x0040);
+		//PHY_REG 27 (1Bh) <- AA40h
+		dm9000_phy_write(dev, 0,  27, 0xaa40);
+		
+		//For long code:
+		//PHY_REG 27 (1Bh) <- 0050h
+		dm9000_phy_write(dev, 0,  27, 0x0050);
+		//PHY_REG 27 (1Bh) <- AA50h
+		dm9000_phy_write(dev, 0,  27, 0xaa50);
+		
+		//PHY_REG 27 (1Bh) <- 006Bh
+		dm9000_phy_write(dev, 0,  27, 0x006b);
+		//PHY_REG 27 (1Bh) <- AA6Bh
+		dm9000_phy_write(dev, 0,  27, 0xaa6b);
+		
+		//PHY_REG 27 (1Bh) <- 007Dh
+		dm9000_phy_write(dev, 0,  27, 0x007d);
+		//PHY_REG 27 (1Bh) <- AA7Dh
+		dm9000_phy_write(dev, 0,  27, 0xaa7d);
+		
+		//PHY_REG 27 (1Bh) <- 008Dh
+		dm9000_phy_write(dev, 0,  27, 0x008d);
+		//PHY_REG 27 (1Bh) <- AA8Dh
+		dm9000_phy_write(dev, 0,  27, 0xaa8d);
+		
+		//PHY_REG 27 (1Bh) <- 009Ch
+		dm9000_phy_write(dev, 0,  27, 0x009c);
+		//PHY_REG 27 (1Bh) <- AA9Ch
+		dm9000_phy_write(dev, 0,  27, 0xaa9c);
+		
+		//PHY_REG 27 (1Bh) <- 00A3h
+		dm9000_phy_write(dev, 0,  27, 0x00a3);
+		//PHY_REG 27 (1Bh) <- AAA3h
+		dm9000_phy_write(dev, 0,  27, 0xaaa3);
+		
+		//PHY_REG 27 (1Bh) <- 00B1h
+		dm9000_phy_write(dev, 0,  27, 0x00b1);
+		//PHY_REG 27 (1Bh) <- AAB1h
+		dm9000_phy_write(dev, 0,  27, 0xaab1);
+		
+		//PHY_REG 27 (1Bh) <- 00C0h
+		dm9000_phy_write(dev, 0,  27, 0x00c0);
+		//PHY_REG 27 (1Bh) <- AAC0h
+		dm9000_phy_write(dev, 0,  27, 0xaac0);
+		
+		//PHY_REG 27 (1Bh) <- 00D2h
+		dm9000_phy_write(dev, 0,  27, 0x00d2);
+		//PHY_REG 27 (1Bh) <- AAD2h
+		dm9000_phy_write(dev, 0,  27, 0xaad2);
+		
+		//PHY_REG 27 (1Bh) <- 00E0h
+		dm9000_phy_write(dev, 0,  27, 0x00e0);
+		//PHY_REG 27 (1Bh) <- AAE0h
+		dm9000_phy_write(dev, 0,  27, 0xaae0);
+		//PHY_REG 27 (1Bh) <- 0000h
+		dm9000_phy_write(dev, 0,  27, 0x0000);
+	}
 }
 
 /*
@@ -792,31 +888,37 @@
 {
 	board_info_t *db = netdev_priv(dev);
 	unsigned int imr;
-	unsigned int ncr;
 
 	dm9000_dbg(db, 1, "entering %s\n", __func__);
 
-	/* I/O mode */
-	db->io_mode = ior(db, DM9000_ISR) >> 6;	/* ISR bit7:6 keeps I/O mode */
-
 	/* Checksum mode */
-	dm9000_set_rx_csum_unlocked(dev, db->rx_csum);
+	dm9000_set_rx_csum(dev, db->rx_csum);
 
+#if 0
 	/* GPIO0 on pre-activate PHY */
 	iow(db, DM9000_GPR, 0);	/* REG_1F bit0 activate phyxcer */
 	iow(db, DM9000_GPCR, GPCR_GEP_CNTL);	/* Let GPIO0 output */
 	iow(db, DM9000_GPR, 0);	/* Enable PHY */
+#endif
 
-	ncr = (db->flags & DM9000_PLATF_EXT_PHY) ? NCR_EXT_PHY : 0;
+	iow(db, DM9000_GPR, 0);	/* GPR (reg_1Fh)bit GPIO0=0 pre-activate PHY */
+	mdelay(20);		/* wait for PHY power-on ready */
 
-	/* if wol is needed, then always set NCR_WAKEEN otherwise we end
-	 * up dumping the wake events if we disable this. There is already
-	 * a wake-mask in DM9000_WCR */
-	if (db->wake_supported)
-		ncr |= NCR_WAKEEN;
+	/* do a software reset and wait 20us */
+	iow(db, DM9000_NCR, 3);
+	udelay(20);		/* wait 20us at least for software reset ok */
+	iow(db, DM9000_NCR, 3);	/* NCR (reg_00h) bit[0] RST=1 & Loopback=1, reset on */
+	udelay(20);		/* wait 20us at least for software reset ok */
+	
+	/* I/O mode */
+	db->io_mode = ior(db, DM9000_ISR) >> 6;	/* ISR bit7:6 keeps I/O mode */
 
-	iow(db, DM9000_NCR, ncr);
+	if (db->flags & DM9000_PLATF_EXT_PHY)
+		iow(db, DM9000_NCR, NCR_EXT_PHY);
 
+	db->op_mode = DM9KS_AUTO;
+	set_PHY_mode(dev);
+	
 	/* Program operating register */
 	iow(db, DM9000_TCR, 0);	        /* TX Polling clear */
 	iow(db, DM9000_BPTR, 0x3f);	/* Less 3Kb, 200us */
@@ -825,9 +927,14 @@
 	/* clear TX status */
 	iow(db, DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);
 	iow(db, DM9000_ISR, ISR_CLR_STATUS); /* Clear interrupt status */
+	
+	if (db->type == TYPE_DM9000B){ /* DM9000B */
+		/* Data bus current driving/sinking capability  */
+		iow(db, DM9000_BUSCR, 0x43);	/* default: 2mA */
+	}
 
 	/* Set address filter table */
-	dm9000_hash_table_unlocked(dev);
+	dm9000_hash_table(dev);
 
 	imr = IMR_PAR | IMR_PTM | IMR_PRM;
 	if (db->type != TYPE_DM9000E)
@@ -1040,8 +1147,8 @@
 		}
 
 		/* Move data from DM9000 */
-		if (GoodPacket &&
-		    ((skb = dev_alloc_skb(RxLen + 4)) != NULL)) {
+		if (GoodPacket
+		    && ((skb = dev_alloc_skb(RxLen + 4)) != NULL)) {
 			skb_reserve(skb, 2);
 			rdptr = (u8 *) skb_put(skb, RxLen - 4);
 
@@ -1123,41 +1230,6 @@
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t dm9000_wol_interrupt(int irq, void *dev_id)
-{
-	struct net_device *dev = dev_id;
-	board_info_t *db = netdev_priv(dev);
-	unsigned long flags;
-	unsigned nsr, wcr;
-
-	spin_lock_irqsave(&db->lock, flags);
-
-	nsr = ior(db, DM9000_NSR);
-	wcr = ior(db, DM9000_WCR);
-
-	dev_dbg(db->dev, "%s: NSR=0x%02x, WCR=0x%02x\n", __func__, nsr, wcr);
-
-	if (nsr & NSR_WAKEST) {
-		/* clear, so we can avoid */
-		iow(db, DM9000_NSR, NSR_WAKEST);
-
-		if (wcr & WCR_LINKST)
-			dev_info(db->dev, "wake by link status change\n");
-		if (wcr & WCR_SAMPLEST)
-			dev_info(db->dev, "wake by sample packet\n");
-		if (wcr & WCR_MAGICST )
-			dev_info(db->dev, "wake by magic packet\n");
-		if (!(wcr & (WCR_LINKST | WCR_SAMPLEST | WCR_MAGICST)))
-			dev_err(db->dev, "wake signalled with no reason? "
-				"NSR=0x%02x, WSR=0x%02x\n", nsr, wcr);
-
-	}
-
-	spin_unlock_irqrestore(&db->lock, flags);
-
-	return (nsr & NSR_WAKEST) ? IRQ_HANDLED : IRQ_NONE;
-}
-
 #ifdef CONFIG_NET_POLL_CONTROLLER
 /*
  *Used by netconsole
@@ -1179,6 +1251,7 @@
 {
 	board_info_t *db = netdev_priv(dev);
 	unsigned long irqflags = db->irq_res->flags & IRQF_TRIGGER_MASK;
+	int i,reg_nsr;
 
 	if (netif_msg_ifup(db))
 		dev_dbg(db->dev, "enabling %s\n", dev->name);
@@ -1191,13 +1264,32 @@
 
 	irqflags |= IRQF_SHARED;
 
-	if (request_irq(dev->irq, dm9000_interrupt, irqflags, dev->name, dev))
+	if (request_irq(dev->irq, &dm9000_interrupt, irqflags, dev->name, dev))
 		return -EAGAIN;
 
 	/* Initialize DM9000 board */
 	dm9000_reset(db);
 	dm9000_init_dm9000(dev);
 
+	db->Speed =10;
+	i=0;
+	do {
+		reg_nsr = ior(db,DM9000_NSR);
+		if(reg_nsr & 0x40) /* link OK!! */
+		{
+			/* wait for detected Speed */
+			mdelay(200);
+			reg_nsr = ior(db,DM9000_NSR);
+			if(reg_nsr & 0x80)
+				db->Speed =10;
+			else
+				db->Speed =100;
+			break;
+		}
+		i++;
+		mdelay(1);
+	}while(i<3000);	/* wait 3 second  */
+
 	/* Init driver variable */
 	db->dbug_cnt = 0;
 
@@ -1412,29 +1504,6 @@
 		goto out;
 	}
 
-	db->irq_wake = platform_get_irq(pdev, 1);
-	if (db->irq_wake >= 0) {
-		dev_dbg(db->dev, "wakeup irq %d\n", db->irq_wake);
-
-		ret = request_irq(db->irq_wake, dm9000_wol_interrupt,
-				  IRQF_SHARED, dev_name(db->dev), ndev);
-		if (ret) {
-			dev_err(db->dev, "cannot get wakeup irq (%d)\n", ret);
-		} else {
-
-			/* test to see if irq is really wakeup capable */
-			ret = set_irq_wake(db->irq_wake, 1);
-			if (ret) {
-				dev_err(db->dev, "irq %d cannot set wakeup (%d)\n",
-					db->irq_wake, ret);
-				ret = 0;
-			} else {
-				set_irq_wake(db->irq_wake, 0);
-				db->wake_supported = 1;
-			}
-		}
-	}
-
 	iosize = resource_size(db->addr_res);
 	db->addr_req = request_mem_region(db->addr_res->start, iosize,
 					  pdev->name);
@@ -1540,7 +1609,8 @@
 	case CHIPR_DM9000A:
 		db->type = TYPE_DM9000A;
 		break;
-	case CHIPR_DM9000B:
+	case CHIPR_DM9000B_1:
+	case CHIPR_DM9000B_2:
 		db->type = TYPE_DM9000B;
 		break;
 	default:
@@ -1588,8 +1658,17 @@
 		/* try reading from mac */
 		
 		mac_src = "chip";
+	#if 1
 		for (i = 0; i < 6; i++)
 			ndev->dev_addr[i] = ior(db, i+DM9000_PAR);
+	#else
+        ndev->dev_addr[0] = 0x00;
+        ndev->dev_addr[1] = 0x09;
+        ndev->dev_addr[2] = 0xc0;
+        ndev->dev_addr[3] = 0xff;
+        ndev->dev_addr[4] = 0xec;
+        ndev->dev_addr[5] = 0x48;
+	#endif
 	}
 
 	if (!is_valid_ether_addr(ndev->dev_addr))
@@ -1626,14 +1705,10 @@
 		db = netdev_priv(ndev);
 		db->in_suspend = 1;
 
-		if (!netif_running(ndev))
-			return 0;
-
-		netif_device_detach(ndev);
-
-		/* only shutdown if not using WoL */
-		if (!db->wake_state)
+		if (netif_running(ndev)) {
+			netif_device_detach(ndev);
 			dm9000_shutdown(ndev);
+		}
 	}
 	return 0;
 }
@@ -1646,13 +1721,10 @@
 	board_info_t *db = netdev_priv(ndev);
 
 	if (ndev) {
+
 		if (netif_running(ndev)) {
-			/* reset if we were not in wake mode to ensure if
-			 * the device was powered off it is in a known state */
-			if (!db->wake_state) {
-				dm9000_reset(db);
-				dm9000_init_dm9000(ndev);
-			}
+			dm9000_reset(db);
+			dm9000_init_dm9000(ndev);
 
 			netif_device_attach(ndev);
 		}
@@ -1662,7 +1734,7 @@
 	return 0;
 }
 
-static const struct dev_pm_ops dm9000_drv_pm_ops = {
+static struct dev_pm_ops dm9000_drv_pm_ops = {
 	.suspend	= dm9000_drv_suspend,
 	.resume		= dm9000_drv_resume,
 };
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/net/dm9000.h kernel-2.6.33/drivers/net/dm9000.h
--- linux-2.6.33.7.2-rt30/drivers/net/dm9000.h	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/net/dm9000.h	2011-05-11 17:36:32.000000000 +0300
@@ -46,11 +46,15 @@
 #define DM9000_SMCR            0x2F
 
 #define DM9000_ETXCSR          0x30
-#define DM9000_TCCR	       0x31
-#define DM9000_RCSR	       0x32
+#define DM9000_TCCR	           0x31
+#define DM9000_RCSR	           0x32
+
+#define DM9000_BUSCR           0x38
+#define DM9000_INTCR           0x39
 
 #define CHIPR_DM9000A	       0x19
-#define CHIPR_DM9000B	       0x1A
+#define CHIPR_DM9000B_1	       0x1A
+#define CHIPR_DM9000B_2	       0x1B
 
 #define DM9000_MRCMDX          0xF0
 #define DM9000_MRCMD           0xF2
@@ -111,13 +115,6 @@
 #define RSR_CE              (1<<1)
 #define RSR_FOE             (1<<0)
 
-#define WCR_LINKEN		(1 << 5)
-#define WCR_SAMPLEEN		(1 << 4)
-#define WCR_MAGICEN		(1 << 3)
-#define WCR_LINKST		(1 << 2)
-#define WCR_SAMPLEST		(1 << 1)
-#define WCR_MAGICST		(1 << 0)
-
 #define FCTR_HWOT(ot)	(( ot & 0xf ) << 4 )
 #define FCTR_LWOT(ot)	( ot & 0xf )
 
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/net/wireless/Kconfig kernel-2.6.33/drivers/net/wireless/Kconfig
--- linux-2.6.33.7.2-rt30/drivers/net/wireless/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/net/wireless/Kconfig	2011-11-21 12:58:12.000000000 +0200
@@ -356,5 +356,7 @@
 source "drivers/net/wireless/rt2x00/Kconfig"
 source "drivers/net/wireless/wl12xx/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
+source "drivers/net/wireless/rtl8192cu/Kconfig"
 
 endif # WLAN
+
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/net/wireless/Makefile kernel-2.6.33/drivers/net/wireless/Makefile
--- linux-2.6.33.7.2-rt30/drivers/net/wireless/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/net/wireless/Makefile	2011-11-21 12:58:12.000000000 +0200
@@ -52,3 +52,4 @@
 obj-$(CONFIG_WL12XX)	+= wl12xx/
 
 obj-$(CONFIG_IWM)	+= iwmc3200wifi/
+obj-$(CONFIG_RTL8192CU)	+= rtl8192cu/ 
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/rtc/Kconfig kernel-2.6.33/drivers/rtc/Kconfig
--- linux-2.6.33.7.2-rt30/drivers/rtc/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/rtc/Kconfig	2011-05-11 17:36:32.000000000 +0300
@@ -867,5 +867,13 @@
 	tristate "Freescale MC13783 RTC"
 	help
 	  This enables support for the Freescale MC13783 PMIC RTC
+	  
+config RTC_DRV_NEXELL
+	tristate "Nexell RTC"
+	depends on ARCH_NEXELL
+	help
+	  Driver for the internal RTC (Realtime Clock) module found on
+	  NX series processor.
+
 
 endif # RTC_CLASS
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/rtc/Makefile kernel-2.6.33/drivers/rtc/Makefile
--- linux-2.6.33.7.2-rt30/drivers/rtc/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/rtc/Makefile	2011-05-11 17:36:32.000000000 +0300
@@ -90,3 +90,5 @@
 obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_NEXELL)	+= rtc-nexell.o
+
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/serial/Kconfig kernel-2.6.33/drivers/serial/Kconfig
--- linux-2.6.33.7.2-rt30/drivers/serial/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/serial/Kconfig	2012-03-26 11:51:20.000000000 +0300
@@ -62,7 +62,7 @@
 	  You can set that using a kernel command line option such as
 	  "console=uart8250,io,0x3f8,9600n8"
 	  "console=uart8250,mmio,0xff5e0000,115200n8".
-	  and it will switch to normal serial console when the corresponding 
+	  and it will switch to normal serial console when the corresponding
 	  port is ready.
 	  "earlycon=uart8250,io,0x3f8,9600n8"
 	  "earlycon=uart8250,mmio,0xff5e0000,115200n8".
@@ -464,7 +464,7 @@
 	help
 	  Select the number of available UART ports for the Samsung S3C
 	  serial driver
-	
+
 config SERIAL_SAMSUNG_DEBUG
 	bool "Samsung SoC serial debug"
 	depends on SERIAL_SAMSUNG && DEBUG_LL
@@ -540,6 +540,47 @@
 	help
 	  Serial port support for the Samsung S5PC100 SoCs
 
+config SERIAL_NEXELL_UART
+    tristate "NXP2120 serial port support"
+    depends on CPU_NXP2120
+    select SERIAL_CORE
+    default y
+    help
+      Serial port support for the Nexell's NXP2120 SOC.
+
+config SERIAL_NEXELL_CONSOLE
+	bool "Support for console on Nexell Soc serial port"
+	depends on SERIAL_NEXELL_UART=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Allow selection of the Nexell's nxp2120 serial ports for use as
+	  an virtual console.
+
+config SERIAL_NEXELL_UART_PORT0
+	bool "Nexell serial port 0"
+	depends on SERIAL_NEXELL_UART
+	default y
+
+config SERIAL_NEXELL_UART_PORT0_RXDMA
+		bool "Support DMA on Nexell serial port 0"
+		depends on SERIAL_NEXELL_UART
+		default n
+
+config SERIAL_NEXELL_UART_PORT1
+	bool "Nexell serial port 1"
+	depends on SERIAL_NEXELL_UART
+	default n
+
+config SERIAL_NEXELL_UART_PORT1_RXDMA
+		bool "Support DMA on Nexell serial port 1"
+		depends on SERIAL_NEXELL_UART
+		default n
+
+config MANGLED_BAUDRATE
+        bool "Mangled baudrate for serial port 1"
+        depends on SERIAL_NEXELL_UART_PORT1
+        default n
+
 config SERIAL_MAX3100
 	tristate "MAX3100 support"
 	depends on SPI
@@ -947,8 +988,8 @@
 	depends on PARISC && !SERIAL_MUX && VT
 	default n
 	help
-	  Saying Y here will enable the software based PDC console to be 
-	  used as the system console.  This is useful for machines in 
+	  Saying Y here will enable the software based PDC console to be
+	  used as the system console.  This is useful for machines in
 	  which the hardware based console has not been written yet.  The
 	  following steps must be competed to use the PDC console:
 
@@ -1156,7 +1197,7 @@
 	depends on CPM2 || 8xx
 	select SERIAL_CORE
 	help
-	  This driver supports the SCC and SMC serial ports on Motorola 
+	  This driver supports the SCC and SMC serial ports on Motorola
 	  embedded PowerPC that contain a CPM1 (8xx) or CPM2 (8xxx)
 
 config SERIAL_CPM_CONSOLE
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/serial/Makefile kernel-2.6.33/drivers/serial/Makefile
--- linux-2.6.33.7.2-rt30/drivers/serial/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/serial/Makefile	2011-05-11 17:36:32.000000000 +0300
@@ -82,3 +82,5 @@
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
 obj-$(CONFIG_SERIAL_TIMBERDALE)	+= timbuart.o
 obj-$(CONFIG_SERIAL_GRLIB_GAISLER_APBUART) += apbuart.o
+obj-$(CONFIG_SERIAL_NEXELL_UART) += serial_nexell.o
+
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/usb/host/ehci.h kernel-2.6.33/drivers/usb/host/ehci.h
--- linux-2.6.33.7.2-rt30/drivers/usb/host/ehci.h	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/usb/host/ehci.h	2011-08-22 11:38:04.000000000 +0300
@@ -62,6 +62,23 @@
 
 #define	EHCI_MAX_ROOT_PORTS	15		/* see HCS_N_PORTS */
 
+// swpark add
+#define CONFIG_NXP2120_USB_BUGFIX
+// ksw add for debugging
+//#define CONFIG_NXP2120_USB_BUGFIX_MSG
+
+/* swpark add for nxp2120 usb host bug */
+#ifdef CONFIG_NXP2120_USB_BUGFIX
+struct nxp2120_usb_bugfix {
+	struct urb *urb;
+	void *org_transfer_buffer;
+	dma_addr_t org_transfer_dma;
+	void *transfer_buffer;
+	dma_addr_t transfer_dma;
+	u32 real_transfer_buffer_length;
+};
+#endif
+
 struct ehci_hcd {			/* one per controller */
 	/* glue to PCI and HCD framework */
 	struct ehci_caps __iomem *caps;
@@ -158,6 +175,12 @@
 	struct dentry		*debug_periodic;
 	struct dentry		*debug_registers;
 #endif
+
+	/* swpark add for nxp2120 usb host bug */
+#ifdef CONFIG_NXP2120_USB_BUGFIX
+    unsigned int         dw_flag_nxp2120_bugfix;
+	struct nxp2120_usb_bugfix nxp2120_bugfix[32];
+#endif
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/usb/host/ehci-hcd.c kernel-2.6.33/drivers/usb/host/ehci-hcd.c
--- linux-2.6.33.7.2-rt30/drivers/usb/host/ehci-hcd.c	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/usb/host/ehci-hcd.c	2011-08-22 11:38:04.000000000 +0300
@@ -834,6 +834,72 @@
  * NOTE:  control, bulk, and interrupt share the same code to append TDs
  * to a (possibly active) QH, and the same QH scanning code.
  */
+
+/* swpark add for nxp2120 usb host bug */
+#ifdef CONFIG_NXP2120_USB_BUGFIX
+static inline int is_bugfix_nxp2120_usb(struct urb *urb)
+{
+	if (usb_urb_dir_out(urb)) {
+		int align_4 = urb->transfer_buffer_length % 4;
+		if (align_4 == 2 || align_4 == 3) {
+			return align_4;
+		}
+	}
+	return 0;
+}
+
+static int rearrange_urb_transmit_buffer(struct nxp2120_usb_bugfix *bugfix, struct urb *urb, int align_4)
+{
+	void *new_buffer;
+	dma_addr_t new_dma_addr;
+	u32 new_buffer_length;
+	u32 *org_word_buf, *new_word_buf;
+	//int copy_count;
+
+	new_buffer_length = ((urb->transfer_buffer_length+3)/4)*4 + 4*3;
+
+	new_buffer = usb_buffer_alloc(urb->dev, new_buffer_length, GFP_KERNEL, &new_dma_addr);
+	if (!new_buffer) {
+		printk("[NXP2120 USB BUGPATCH] Error: can't alloc new buffer size(%d)\n", new_buffer_length);
+		return -1;
+	}
+
+	// copy all org buffer to new buffer
+	memcpy(new_buffer, urb->transfer_buffer, urb->transfer_buffer_length);
+
+	if (urb->transfer_buffer_length > 4)
+		org_word_buf = (u32 *)urb->transfer_buffer + (urb->transfer_buffer_length-1)/4; // last buffer
+	else
+		org_word_buf = (u32 *)urb->transfer_buffer;
+
+	new_word_buf = (u32 *)new_buffer + urb->transfer_buffer_length/4;
+
+	//copy_count = new_buffer_length - urb->transfer_buffer_length;
+	new_word_buf++;
+	*new_word_buf = *org_word_buf;
+	new_word_buf++;
+	*new_word_buf = *org_word_buf;
+	new_word_buf++;
+	*new_word_buf = *org_word_buf;
+
+	bugfix->urb = urb;
+	bugfix->org_transfer_buffer = urb->transfer_buffer;
+	bugfix->org_transfer_dma = urb->transfer_dma;
+	bugfix->real_transfer_buffer_length = new_buffer_length;
+	bugfix->transfer_buffer = new_buffer;
+	bugfix->transfer_dma    = new_dma_addr;
+
+	urb->transfer_buffer = new_buffer;
+	urb->transfer_dma = new_dma_addr;
+
+#ifdef CONFIG_NXP2120_USB_BUGFIX_MSG
+    printk("Alloc: %p, 0x%x, %d(org:%x %x)\n", urb->transfer_buffer, urb->transfer_dma, bugfix->real_transfer_buffer_length, bugfix->org_transfer_buffer, bugfix->org_transfer_dma);
+#endif
+
+	return 0;
+}
+#endif
+
 static int ehci_urb_enqueue (
 	struct usb_hcd	*hcd,
 	struct urb	*urb,
@@ -844,6 +910,63 @@
 
 	INIT_LIST_HEAD (&qtd_list);
 
+	/* swpark add for nxp2120 usb mem read bugfix */
+#ifdef CONFIG_NXP2120_USB_BUGFIX
+	{
+		int align_4 = is_bugfix_nxp2120_usb(urb);
+		if (align_4 == 2 || align_4 == 3) {
+		    int i;
+		    unsigned t;
+		    int done = 0;
+		    t = 1;
+		    for (i=0; i<32; i++) {
+		        if ((t & ehci->dw_flag_nxp2120_bugfix) && (ehci->nxp2120_bugfix[i].urb == urb)) {/* If this urb is already used urb, not to do anything */
+		            int ret;
+		            struct nxp2120_usb_bugfix *bugfix = &ehci->nxp2120_bugfix[i];
+		            if (ehci->nxp2120_bugfix[i].transfer_buffer != urb->transfer_buffer) { /* but if this urb has new transfer address, alloc new buffer */
+		                usb_buffer_free(urb->dev, bugfix->real_transfer_buffer_length, bugfix->transfer_buffer, bugfix->transfer_dma);
+		                ret = rearrange_urb_transmit_buffer(bugfix, urb, align_4);
+		                if (ret < 0) {
+				            printk("[NXP2120 USB BUGPATCH]:1 return ENOMEM\n");
+				            return -ENOMEM;
+				        }
+		            }
+		            done = 1;
+		            break;
+		        }
+		        t <<= 1;
+		    }
+		    if (!done) {
+		        t = 1;
+		        for (i=0; i<32; i++) {
+		            if (0 == (t & ehci->dw_flag_nxp2120_bugfix)) {
+		                int ret;
+		                struct nxp2120_usb_bugfix *bugfix;
+		                bugfix = &ehci->nxp2120_bugfix[i];
+		                memset(bugfix, 0, sizeof(struct nxp2120_usb_bugfix));
+#ifdef CONFIG_NXP2120_USB_BUGFIX_MSG
+                        printk("===> Enter BugPatch: %d tr length(%d)\n", align_4, urb->transfer_buffer_length);
+#endif
+				        ret = rearrange_urb_transmit_buffer(bugfix, urb, align_4);
+				        if (ret < 0) {
+				            printk("[NXP2120 USB BUGPATCH]:2 return ENOMEM\n");
+				            return -ENOMEM;
+				        }
+				        ehci->dw_flag_nxp2120_bugfix |= t;
+				        done = 1;
+				        break;
+				    }
+				    t <<= 1;
+				}
+				if (!done) {
+				    printk("[NXP2120 USB BUGPATCH] can't alloc bugfix struct return ENOMEM\n");
+				    return -ENOMEM;
+				}
+			}
+		}
+	}
+#endif
+
 	switch (usb_pipetype (urb->pipe)) {
 	case PIPE_CONTROL:
 		/* qh_completions() code doesn't handle all the fault cases
@@ -1159,6 +1282,11 @@
 #define	PLATFORM_DRIVER		ehci_atmel_driver
 #endif
 
+#ifdef CONFIG_ARCH_NEXELL
+#include "ehci-nexell.c"
+#define PLATFORM_DRIVER		ehci_hcd_nexell_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/usb/host/ehci-q.c kernel-2.6.33/drivers/usb/host/ehci-q.c
--- linux-2.6.33.7.2-rt30/drivers/usb/host/ehci-q.c	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/usb/host/ehci-q.c	2011-08-22 11:38:04.000000000 +0300
@@ -292,6 +292,33 @@
 	/* complete() can reenter this HCD */
 	usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 	spin_unlock (&ehci->lock);
+
+	/* swpark add for nxp2120 usb host bug */
+#ifdef CONFIG_NXP2120_USB_BUGFIX
+	if (ehci->dw_flag_nxp2120_bugfix) { //ehci->dw_flag_nxp2120_bugfix
+	    int i;
+	    unsigned t;
+	    t = 1;
+	    for (i=0; i<32; i++) {
+	        if ((t & ehci->dw_flag_nxp2120_bugfix) && (urb == ehci->nxp2120_bugfix[i].urb)) { //  
+	            struct nxp2120_usb_bugfix *bugfix = &ehci->nxp2120_bugfix[i];
+#ifdef CONFIG_NXP2120_USB_BUGFIX_MSG
+		        printk("Free: %p, 0x%x, %d %x\n", urb->transfer_buffer, urb->transfer_dma, bugfix->real_transfer_buffer_length, bugfix->org_transfer_dma);
+#endif
+		        usb_buffer_free(urb->dev, bugfix->real_transfer_buffer_length, urb->transfer_buffer, urb->transfer_dma);
+		        urb->transfer_buffer = bugfix->org_transfer_buffer;
+		        urb->transfer_dma = bugfix->org_transfer_dma;
+		        ehci->dw_flag_nxp2120_bugfix &= ~t;
+#ifdef CONFIG_NXP2120_USB_BUGFIX_MSG
+		        printk("<=== end bugfix\n");
+#endif
+                break;
+		    }
+		    t <<= 1;
+		}
+	}
+#endif
+
 	usb_hcd_giveback_urb(ehci_to_hcd(ehci), urb, status);
 	spin_lock (&ehci->lock);
 }
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/usb/host/ohci-hcd.c kernel-2.6.33/drivers/usb/host/ohci-hcd.c
--- linux-2.6.33.7.2-rt30/drivers/usb/host/ohci-hcd.c	2016-06-18 12:51:17.713354247 +0300
+++ kernel-2.6.33/drivers/usb/host/ohci-hcd.c	2011-05-18 11:11:42.000000000 +0300
@@ -1089,6 +1089,11 @@
 #define TMIO_OHCI_DRIVER	ohci_hcd_tmio_driver
 #endif
 
+#ifdef CONFIG_ARCH_NEXELL
+#include "ohci-nexell.c"
+#define PLATFORM_DRIVER		ohci_hcd_nexell_driver
+#endif
+
 #if	!defined(PCI_DRIVER) &&		\
 	!defined(PLATFORM_DRIVER) &&	\
 	!defined(OF_PLATFORM_DRIVER) &&	\
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/drivers/usb/Kconfig kernel-2.6.33/drivers/usb/Kconfig
--- linux-2.6.33.7.2-rt30/drivers/usb/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/drivers/usb/Kconfig	2011-05-11 17:36:32.000000000 +0300
@@ -39,6 +39,7 @@
 	default y if ARCH_PNX4008 && I2C
 	default y if MFD_TC6393XB
 	default y if ARCH_W90X900
+	default y if ARCH_NEXELL
 	# PPC:
 	default y if STB03xxx
 	default y if PPC_MPC52xx
@@ -62,6 +63,7 @@
 	default y if ARCH_AT91SAM9G45
 	default y if ARCH_MXC
 	default y if ARCH_OMAP34XX
+	default y if ARCH_NEXELL
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/fs/Kconfig kernel-2.6.33/fs/Kconfig
--- linux-2.6.33.7.2-rt30/fs/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/fs/Kconfig	2011-05-11 17:36:32.000000000 +0300
@@ -177,6 +177,8 @@
 source "fs/jffs2/Kconfig"
 # UBIFS File system configuration
 source "fs/ubifs/Kconfig"
+# YAFFS2
+source "fs/yaffs2/Kconfig"
 source "fs/cramfs/Kconfig"
 source "fs/squashfs/Kconfig"
 source "fs/freevxfs/Kconfig"
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/fs/Makefile kernel-2.6.33/fs/Makefile
--- linux-2.6.33.7.2-rt30/fs/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/fs/Makefile	2011-05-11 17:36:32.000000000 +0300
@@ -100,6 +100,7 @@
 obj-$(CONFIG_EFS_FS)		+= efs/
 obj-$(CONFIG_JFFS2_FS)		+= jffs2/
 obj-$(CONFIG_UBIFS_FS)		+= ubifs/
+obj-$(CONFIG_YAFFS_FS)         += yaffs2/
 obj-$(CONFIG_AFFS_FS)		+= affs/
 obj-$(CONFIG_ROMFS_FS)		+= romfs/
 obj-$(CONFIG_QNX4FS_FS)		+= qnx4/
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/include/linux/mqueue.h kernel-2.6.33/include/linux/mqueue.h
--- linux-2.6.33.7.2-rt30/include/linux/mqueue.h	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/include/linux/mqueue.h	2011-05-18 11:11:42.000000000 +0300
@@ -20,7 +20,7 @@
 
 #define MQ_PRIO_MAX 	32768
 /* per-uid limit of kernel memory used by mqueue, in bytes */
-#define MQ_BYTES_MAX	819200
+#define MQ_BYTES_MAX	8392704 /* Changed by ksw, formerly 819200 */
 
 struct mq_attr {
 	long	mq_flags;	/* message queue flags			*/
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/include/linux/semaphore.h kernel-2.6.33/include/linux/semaphore.h
--- linux-2.6.33.7.2-rt30/include/linux/semaphore.h	2016-06-18 12:51:17.737354595 +0300
+++ kernel-2.6.33/include/linux/semaphore.h	2011-05-18 11:11:42.000000000 +0300
@@ -29,6 +29,9 @@
 #define DEFINE_SEMAPHORE(name, val)					\
 	struct semaphore name = __SEMAPHORE_INITIALIZER(name, val)
 
+#define init_MUTEX(sem)         sema_init(sem, 1)
+#define init_MUTEX_LOCKED(sem)  sema_init(sem, 0)
+
 static inline void sema_init(struct semaphore *sem, int val)
 {
 	static struct lock_class_key __key;
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/init/version.c kernel-2.6.33/init/version.c
--- linux-2.6.33.7.2-rt30/init/version.c	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/init/version.c	2011-05-18 13:13:56.000000000 +0300
@@ -39,7 +39,7 @@
 /* FIXED STRINGS! Don't touch! */
 const char linux_banner[] =
 	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
-	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
+	LINUX_COMPILE_HOST ", " SUBVERSION_REVISION ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
 
 const char linux_proc_banner[] =
 	"%s version %s"
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/kernel/sys.c kernel-2.6.33/kernel/sys.c
--- linux-2.6.33.7.2-rt30/kernel/sys.c	2016-06-18 12:51:17.757354886 +0300
+++ kernel-2.6.33/kernel/sys.c	2012-03-05 14:01:34.000000000 +0200
@@ -470,7 +470,7 @@
 	else
 		kill_cad_pid(SIGINT, 1);
 }
-	
+
 /*
  * Unprivileged users may change the real gid to the effective gid
  * or vice versa.  (BSD-style)
@@ -484,7 +484,7 @@
  *
  * The general idea is that a program which uses just setregid() will be
  * 100% compatible with BSD.  A program which uses just setgid() will be
- * 100% compatible with POSIX with saved IDs. 
+ * 100% compatible with POSIX with saved IDs.
  *
  * SMP: There are not races, the GIDs are checked only by filesystem
  *      operations (as far as semantic preservation is concerned).
@@ -536,7 +536,7 @@
 }
 
 /*
- * setgid() is implemented like SysV w/ SAVED_IDS 
+ * setgid() is implemented like SysV w/ SAVED_IDS
  *
  * SMP: Same implicit races as above.
  */
@@ -611,7 +611,7 @@
  *
  * The general idea is that a program which uses just setreuid() will be
  * 100% compatible with BSD.  A program which uses just setuid() will be
- * 100% compatible with POSIX with saved IDs. 
+ * 100% compatible with POSIX with saved IDs.
  */
 SYSCALL_DEFINE2(setreuid, uid_t, ruid, uid_t, euid)
 {
@@ -666,17 +666,17 @@
 	abort_creds(new);
 	return retval;
 }
-		
+
 /*
- * setuid() is implemented like SysV with SAVED_IDS 
- * 
+ * setuid() is implemented like SysV with SAVED_IDS
+ *
  * Note that SAVED_ID's is deficient in that a setuid root program
- * like sendmail, for example, cannot set its uid to be a normal 
+ * like sendmail, for example, cannot set its uid to be a normal
  * user and then switch back, because if you're root, setuid() sets
  * the saved uid too.  If you don't like this, blame the bright people
  * in the POSIX committee and/or USG.  Note that the BSD-style setreuid()
  * will allow a root program to temporarily drop privileges and be able to
- * regain them by swapping the real and effective uid.  
+ * regain them by swapping the real and effective uid.
  */
 SYSCALL_DEFINE1(setuid, uid_t, uid)
 {
@@ -1231,7 +1231,7 @@
 /*
  *	Back compatibility for getrlimit. Needed for some apps.
  */
- 
+
 SYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,
 		struct rlimit __user *, rlim)
 {
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/scripts/mkcompile_h kernel-2.6.33/scripts/mkcompile_h
--- linux-2.6.33.7.2-rt30/scripts/mkcompile_h	2016-06-18 12:51:17.773355118 +0300
+++ kernel-2.6.33/scripts/mkcompile_h	2013-07-17 17:10:32.000000000 +0300
@@ -82,6 +82,7 @@
   fi
 
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
+  echo \#define SUBVERSION_REVISION \"At revision 93\(R154\).\"
 ) > .tmpcompile
 
 # Only replace the real compile.h if the new one is different,
@@ -103,3 +104,4 @@
    mv -f .tmpcompile $TARGET
 fi
 rm -f .tmpver.1 .tmpver.2
+
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/sound/soc/codecs/Kconfig kernel-2.6.33/sound/soc/codecs/Kconfig
--- linux-2.6.33.7.2-rt30/sound/soc/codecs/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/sound/soc/codecs/Kconfig	2011-09-06 20:45:42.000000000 +0300
@@ -209,6 +209,9 @@
 config SND_SOC_WM8960
 	tristate
 
+config SND_SOC_TWO_WM8960
+	tristate
+
 config SND_SOC_WM8961
 	tristate
 
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/sound/soc/codecs/Makefile kernel-2.6.33/sound/soc/codecs/Makefile
--- linux-2.6.33.7.2-rt30/sound/soc/codecs/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/sound/soc/codecs/Makefile	2011-09-06 20:45:42.000000000 +0300
@@ -38,6 +38,7 @@
 snd-soc-wm8903-objs := wm8903.o
 snd-soc-wm8940-objs := wm8940.o
 snd-soc-wm8960-objs := wm8960.o
+snd-soc-two-wm8960-objs := two_wm8960.o
 snd-soc-wm8961-objs := wm8961.o
 snd-soc-wm8971-objs := wm8971.o
 snd-soc-wm8974-objs := wm8974.o
@@ -105,7 +106,7 @@
 obj-$(CONFIG_SND_SOC_WM9712)	+= snd-soc-wm9712.o
 obj-$(CONFIG_SND_SOC_WM9713)	+= snd-soc-wm9713.o
 obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
-
+obj-$(CONFIG_SND_SOC_TWO_WM8960)	+= snd-soc-two-wm8960.o
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/sound/soc/codecs/wm8960.c kernel-2.6.33/sound/soc/codecs/wm8960.c
--- linux-2.6.33.7.2-rt30/sound/soc/codecs/wm8960.c	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/sound/soc/codecs/wm8960.c	2011-07-04 16:16:42.000000000 +0300
@@ -79,6 +79,10 @@
 static const char *wm8960_3d_lower_cutoff[] = {"Low", "High"};
 static const char *wm8960_alcfunc[] = {"Off", "Right", "Left", "Stereo"};
 static const char *wm8960_alcmode[] = {"ALC", "Limiter"};
+static const char *wm8960_recordmode[] = {"Stereo", "Left", "Right", "Swap Left&Right"};
+static const char *wm8960_speakermode[] = {"All off","Left only","Right only", "Stereo"};
+static const char *wm8960_micbias[] = {"High", "Low"};
+static const char *wm8960_micboost[] = {"+0dB", "+13dB", "+20dB", "+29dB"};
 
 static const struct soc_enum wm8960_enum[] = {
 	SOC_ENUM_SINGLE(WM8960_DACCTL1, 1, 4, wm8960_deemph),
@@ -88,16 +92,22 @@
 	SOC_ENUM_SINGLE(WM8960_3D, 5, 2, wm8960_3d_lower_cutoff),
 	SOC_ENUM_SINGLE(WM8960_ALC1, 7, 4, wm8960_alcfunc),
 	SOC_ENUM_SINGLE(WM8960_ALC3, 8, 2, wm8960_alcmode),
+	SOC_ENUM_SINGLE(WM8960_ADDCTL1, 2, 4, wm8960_recordmode),
+	SOC_ENUM_SINGLE(WM8960_CLASSD1, 6, 4, wm8960_speakermode),
+	SOC_ENUM_SINGLE(WM8960_ADDCTL4, 0, 2, wm8960_micbias),
+	SOC_ENUM_SINGLE(WM8960_LINPATH, 4, 4, wm8960_micboost),
+	SOC_ENUM_SINGLE(WM8960_RINPATH, 4, 4, wm8960_micboost),
 };
 
-static const DECLARE_TLV_DB_SCALE(adc_tlv, -9700, 50, 0);
+static const DECLARE_TLV_DB_SCALE(adc_tlv, -9700, 50, 1);
 static const DECLARE_TLV_DB_SCALE(dac_tlv, -12700, 50, 1);
 static const DECLARE_TLV_DB_SCALE(bypass_tlv, -2100, 300, 0);
 static const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);
+static const DECLARE_TLV_DB_SCALE(in_tlv, -1725, 75, 0);
 
 static const struct snd_kcontrol_new wm8960_snd_controls[] = {
 SOC_DOUBLE_R_TLV("Capture Volume", WM8960_LINVOL, WM8960_RINVOL,
-		 0, 63, 0, adc_tlv),
+		 0, 63, 0, in_tlv),
 SOC_DOUBLE_R("Capture Volume ZC Switch", WM8960_LINVOL, WM8960_RINVOL,
 	6, 1, 0),
 SOC_DOUBLE_R("Capture Switch", WM8960_LINVOL, WM8960_RINVOL,
@@ -115,6 +125,7 @@
 		 0, 127, 0, out_tlv),
 SOC_DOUBLE_R("Speaker Playback ZC Switch", WM8960_LOUT2, WM8960_ROUT2,
 	7, 1, 0),
+SOC_ENUM("Speaker Playback Off Switch", wm8960_enum[8]),
 SOC_SINGLE("Speaker DC Volume", WM8960_CLASSD3, 3, 5, 0),
 SOC_SINGLE("Speaker AC Volume", WM8960_CLASSD3, 0, 5, 0),
 
@@ -122,6 +133,7 @@
 SOC_ENUM("ADC Polarity", wm8960_enum[1]),
 SOC_ENUM("Playback De-emphasis", wm8960_enum[0]),
 SOC_SINGLE("ADC High Pass Filter Switch", WM8960_DACCTL1, 0, 1, 0),
+SOC_ENUM("Record channels", wm8960_enum[7]),
 
 SOC_ENUM("DAC Polarity", wm8960_enum[2]),
 
@@ -142,8 +154,10 @@
 SOC_SINGLE("Noise Gate Threshold", WM8960_NOISEG, 3, 31, 0),
 SOC_SINGLE("Noise Gate Switch", WM8960_NOISEG, 0, 1, 0),
 
-SOC_DOUBLE_R("ADC PCM Capture Volume", WM8960_LINPATH, WM8960_RINPATH,
-	0, 127, 0),
+SOC_DOUBLE_R_TLV("ADC PCM Capture Volume", WM8960_LADC, WM8960_RADC,
+	0, 255, 0, adc_tlv),
+SOC_ENUM("Left PGA Boost Gain", wm8960_enum[10]),
+SOC_ENUM("Right PGA Boost Gain", wm8960_enum[11]),
 
 SOC_SINGLE_TLV("Left Output Mixer Boost Bypass Volume",
 	       WM8960_BYPASS1, 4, 7, 1, bypass_tlv),
@@ -153,6 +167,7 @@
 	       WM8960_BYPASS2, 4, 7, 1, bypass_tlv),
 SOC_SINGLE_TLV("Right Output Mixer RINPUT3 Volume",
 	       WM8960_ROUTMIX, 4, 7, 1, bypass_tlv),
+SOC_ENUM("Microphone Bias", wm8960_enum[9]),
 };
 
 static const struct snd_kcontrol_new wm8960_lin_boost[] = {
@@ -212,8 +227,8 @@
 SND_SOC_DAPM_MIXER("Right Input Mixer", WM8960_POWER3, 4, 0,
 		   wm8960_rin, ARRAY_SIZE(wm8960_rin)),
 
-SND_SOC_DAPM_ADC("Left ADC", "Capture", WM8960_POWER2, 3, 0),
-SND_SOC_DAPM_ADC("Right ADC", "Capture", WM8960_POWER2, 2, 0),
+SND_SOC_DAPM_ADC("Left ADC", "Capture", WM8960_POWER1, 3, 0),
+SND_SOC_DAPM_ADC("Right ADC", "Capture", WM8960_POWER1, 2, 0),
 
 SND_SOC_DAPM_DAC("Left DAC", "Playback", WM8960_POWER2, 8, 0),
 SND_SOC_DAPM_DAC("Right DAC", "Playback", WM8960_POWER2, 7, 0),
@@ -314,7 +329,7 @@
 		unsigned int fmt)
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
-	u16 iface = 0;
+	u16 iface = snd_soc_read(codec, WM8960_IFACE1) & 0x1F0;
 
 	/* set master/slave audio interface */
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
@@ -501,9 +516,10 @@
 	pr_debug("WM8960 PLL: setting %dHz->%dHz\n", source, target);
 
 	/* Scale up target to PLL operating frequency */
-	target *= 4;
+	target *= 8;
 
 	Ndiv = target / source;
+	//printk("Ndiv = %d\n", Ndiv);
 	if (Ndiv < 6) {
 		source >>= 1;
 		pll_div->pre_div = 1;
@@ -519,6 +535,8 @@
 	pll_div->n = Ndiv;
 	Nmod = target % source;
 	Kpart = FIXED_PLL_SIZE * (long long)Nmod;
+	
+	//printk("Kpart = %d\n", Kpart);
 
 	do_div(Kpart, source);
 
@@ -532,6 +550,8 @@
 	K /= 10;
 
 	pll_div->k = K;
+	
+	//printk("K = %d\n", K);
 
 	pr_debug("WM8960 PLL: N=%x K=%x pre_div=%d\n",
 		 pll_div->n, pll_div->k, pll_div->pre_div);
@@ -547,6 +567,8 @@
 	static struct _pll_div pll_div;
 	int ret;
 
+    //printk("WM8960 PLL: in =%d out= %d \n", freq_in, freq_out);
+
 	if (freq_in && freq_out) {
 		ret = pll_factors(freq_in, freq_out, &pll_div);
 		if (ret != 0)
@@ -556,7 +578,7 @@
 	/* Disable the PLL: even if we are changing the frequency the
 	 * PLL needs to be disabled while we do so. */
 	snd_soc_write(codec, WM8960_CLOCK1,
-		     snd_soc_read(codec, WM8960_CLOCK1) & ~1);
+		     snd_soc_read(codec, WM8960_CLOCK1) & ~7);
 	snd_soc_write(codec, WM8960_POWER2,
 		     snd_soc_read(codec, WM8960_POWER2) & ~1);
 
@@ -570,9 +592,15 @@
 	if (pll_div.k) {
 		reg |= 0x20;
 
+#if 0
 		snd_soc_write(codec, WM8960_PLL2, (pll_div.k >> 18) & 0x3f);
 		snd_soc_write(codec, WM8960_PLL3, (pll_div.k >> 9) & 0x1ff);
 		snd_soc_write(codec, WM8960_PLL4, pll_div.k & 0x1ff);
+#else
+		snd_soc_write(codec, WM8960_PLL2, (pll_div.k >> 16) & 0xff);
+		snd_soc_write(codec, WM8960_PLL3, (pll_div.k >> 8) & 0x0ff);
+		snd_soc_write(codec, WM8960_PLL4, pll_div.k & 0xff);
+#endif
 	}
 	snd_soc_write(codec, WM8960_PLL1, reg);
 
@@ -581,7 +609,7 @@
 		     snd_soc_read(codec, WM8960_POWER2) | 1);
 	msleep(250);
 	snd_soc_write(codec, WM8960_CLOCK1,
-		     snd_soc_read(codec, WM8960_CLOCK1) | 1);
+		     snd_soc_read(codec, WM8960_CLOCK1) | 1 | (0x02 << 1));
 
 	return 0;
 }
@@ -605,6 +633,10 @@
 		reg = snd_soc_read(codec, WM8960_CLOCK1) & 0x1c7;
 		snd_soc_write(codec, WM8960_CLOCK1, reg | div);
 		break;
+	case WM8960_ADCDIV:
+		reg = snd_soc_read(codec, WM8960_CLOCK1) & 0x03F;
+		snd_soc_write(codec, WM8960_CLOCK1, reg | div);
+		break;
 	case WM8960_OPCLKDIV:
 		reg = snd_soc_read(codec, WM8960_PLL1) & 0x03f;
 		snd_soc_write(codec, WM8960_PLL1, reg | div);
@@ -617,6 +649,10 @@
 		reg = snd_soc_read(codec, WM8960_ADDCTL1) & 0x1fd;
 		snd_soc_write(codec, WM8960_ADDCTL1, reg | div);
 		break;
+	case WM8960_BCLKDIV:
+		reg = snd_soc_read(codec, WM8960_CLOCK2) & 0x1F0;
+		snd_soc_write(codec, WM8960_CLOCK2, reg | div);
+		break;
 	default:
 		return -EINVAL;
 	}
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/sound/soc/codecs/wm8960.h kernel-2.6.33/sound/soc/codecs/wm8960.h
--- linux-2.6.33.7.2-rt30/sound/soc/codecs/wm8960.h	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/sound/soc/codecs/wm8960.h	2011-09-08 06:46:34.000000000 +0300
@@ -73,10 +73,12 @@
  */
 #define WM8960_SYSCLKDIV 		0
 #define WM8960_DACDIV			1
-#define WM8960_OPCLKDIV			2
-#define WM8960_DCLKDIV			3
-#define WM8960_TOCLKSEL			4
-#define WM8960_SYSCLKSEL		5
+#define WM8960_ADCDIV			2
+#define WM8960_OPCLKDIV			3
+#define WM8960_DCLKDIV			4
+#define WM8960_TOCLKSEL			5
+#define WM8960_SYSCLKSEL		6
+#define WM8960_BCLKDIV  		7
 
 #define WM8960_SYSCLK_DIV_1		(0 << 1)
 #define WM8960_SYSCLK_DIV_2		(2 << 1)
@@ -92,6 +94,14 @@
 #define WM8960_DAC_DIV_5_5		(5 << 3)
 #define WM8960_DAC_DIV_6		(6 << 3)
 
+#define WM8960_ADC_DIV_1		(0 << 6)
+#define WM8960_ADC_DIV_1_5		(1 << 6)
+#define WM8960_ADC_DIV_2		(2 << 6)
+#define WM8960_ADC_DIV_3		(3 << 6)
+#define WM8960_ADC_DIV_4		(4 << 6)
+#define WM8960_ADC_DIV_5_5		(5 << 6)
+#define WM8960_ADC_DIV_6		(6 << 6)
+
 #define WM8960_DCLK_DIV_1_5		(0 << 6)
 #define WM8960_DCLK_DIV_2		(1 << 6)
 #define WM8960_DCLK_DIV_3		(2 << 6)
@@ -111,8 +121,26 @@
 #define WM8960_OPCLK_DIV_5_5		(4 << 0)
 #define WM8960_OPCLK_DIV_6		(5 << 0)
 
+#define WM8960_BCLK_DIV_1		(0 << 0)
+#define WM8960_BCLK_DIV_1_5		(1 << 0)
+#define WM8960_BCLK_DIV_2		(2 << 0)
+#define WM8960_BCLK_DIV_3		(3 << 0)
+#define WM8960_BCLK_DIV_4	    (4 << 0)
+#define WM8960_BCLK_DIV_5_5		(5 << 0)
+#define WM8960_BCLK_DIV_6		(6 << 0)
+#define WM8960_BCLK_DIV_8		(7 << 0)
+#define WM8960_BCLK_DIV_11		(8 << 0)
+#define WM8960_BCLK_DIV_12		(9 << 0)
+#define WM8960_BCLK_DIV_16	    (10 << 0)
+#define WM8960_BCLK_DIV_22		(11 << 0)
+#define WM8960_BCLK_DIV_24		(12 << 0)
+#define WM8960_BCLK_DIV_32		(13 << 0)
+
 extern struct snd_soc_dai wm8960_dai;
+extern struct snd_soc_dai wm8960_2_dai;
+extern struct snd_soc_dai wm8960_3_dai;
 extern struct snd_soc_codec_device soc_codec_dev_wm8960;
+extern struct snd_soc_codec_device soc_codec_dev_two_wm8960;
 
 #define WM8960_DRES_400R 0
 #define WM8960_DRES_200R 1
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/sound/soc/Kconfig kernel-2.6.33/sound/soc/Kconfig
--- linux-2.6.33.7.2-rt30/sound/soc/Kconfig	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/sound/soc/Kconfig	2011-05-11 17:36:32.000000000 +0300
@@ -36,6 +36,7 @@
 source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/txx9/Kconfig"
+source "sound/soc/nexell/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff -Nur -x TEST.doc -x TEST.DOC -x system.dts -x '*.txt' linux-2.6.33.7.2-rt30/sound/soc/Makefile kernel-2.6.33/sound/soc/Makefile
--- linux-2.6.33.7.2-rt30/sound/soc/Makefile	2010-08-02 20:27:18.000000000 +0300
+++ kernel-2.6.33/sound/soc/Makefile	2011-05-11 17:36:32.000000000 +0300
@@ -14,3 +14,4 @@
 obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= txx9/
+obj-$(CONFIG_SND_SOC)	+= nexell/
